/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server/lib/theme-partials/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent = window.CustomEvent;\nif (!supportCustomEvent || typeof supportCustomEvent === 'object') {\n  supportCustomEvent = function CustomEvent(event, x) {\n    x = x || {};\n    var ev = document.createEvent('CustomEvent');\n    ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n    return ev;\n  };\n  supportCustomEvent.prototype = window.Event.prototype;\n}\n\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */\nfunction createsStackingContext(el) {\n  while (el && el !== document.body) {\n    var s = window.getComputedStyle(el);\n    var invalid = function(k, ok) {\n      return !(s[k] === undefined || s[k] === ok);\n    };\n    \n    if (s.opacity < 1 ||\n        invalid('zIndex', 'auto') ||\n        invalid('transform', 'none') ||\n        invalid('mixBlendMode', 'normal') ||\n        invalid('filter', 'none') ||\n        invalid('perspective', 'none') ||\n        s['isolation'] === 'isolate' ||\n        s.position === 'fixed' ||\n        s.webkitOverflowScrolling === 'touch') {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n}\n\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */\nfunction findNearestDialog(el) {\n  while (el) {\n    if (el.localName === 'dialog') {\n      return /** @type {HTMLDialogElement} */ (el);\n    }\n    el = el.parentElement;\n  }\n  return null;\n}\n\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */\nfunction safeBlur(el) {\n  if (el && el.blur && el !== document.body) {\n    el.blur();\n  }\n}\n\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */\nfunction inNodeList(nodeList, node) {\n  for (var i = 0; i < nodeList.length; ++i) {\n    if (nodeList[i] === node) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */\nfunction isFormMethodDialog(el) {\n  if (!el || !el.hasAttribute('method')) {\n    return false;\n  }\n  return el.getAttribute('method').toLowerCase() === 'dialog';\n}\n\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */\nfunction dialogPolyfillInfo(dialog) {\n  this.dialog_ = dialog;\n  this.replacedStyleTop_ = false;\n  this.openAsModal_ = false;\n\n  // Set a11y role. Browsers that support dialog implicitly know this already.\n  if (!dialog.hasAttribute('role')) {\n    dialog.setAttribute('role', 'dialog');\n  }\n\n  dialog.show = this.show.bind(this);\n  dialog.showModal = this.showModal.bind(this);\n  dialog.close = this.close.bind(this);\n\n  if (!('returnValue' in dialog)) {\n    dialog.returnValue = '';\n  }\n\n  if ('MutationObserver' in window) {\n    var mo = new MutationObserver(this.maybeHideModal.bind(this));\n    mo.observe(dialog, {attributes: true, attributeFilter: ['open']});\n  } else {\n    // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n    // seem to fire even if the element was removed as part of a parent removal. Use the removed\n    // events to force downgrade (useful if removed/immediately added).\n    var removed = false;\n    var cb = function() {\n      removed ? this.downgradeModal() : this.maybeHideModal();\n      removed = false;\n    }.bind(this);\n    var timeout;\n    var delayModel = function(ev) {\n      if (ev.target !== dialog) { return; }  // not for a child element\n      var cand = 'DOMNodeRemoved';\n      removed |= (ev.type.substr(0, cand.length) === cand);\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(cb, 0);\n    };\n    ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {\n      dialog.addEventListener(name, delayModel);\n    });\n  }\n  // Note that the DOM is observed inside DialogManager while any dialog\n  // is being displayed as a modal, to catch modal removal from the DOM.\n\n  Object.defineProperty(dialog, 'open', {\n    set: this.setOpen.bind(this),\n    get: dialog.hasAttribute.bind(dialog, 'open')\n  });\n\n  this.backdrop_ = document.createElement('div');\n  this.backdrop_.className = 'backdrop';\n  this.backdrop_.addEventListener('click', this.backdropClick_.bind(this));\n}\n\ndialogPolyfillInfo.prototype = {\n\n  get dialog() {\n    return this.dialog_;\n  },\n\n  /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */\n  maybeHideModal: function() {\n    if (this.dialog_.hasAttribute('open') && document.body.contains(this.dialog_)) { return; }\n    this.downgradeModal();\n  },\n\n  /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */\n  downgradeModal: function() {\n    if (!this.openAsModal_) { return; }\n    this.openAsModal_ = false;\n    this.dialog_.style.zIndex = '';\n\n    // This won't match the native <dialog> exactly because if the user set top on a centered\n    // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n    // possible to polyfill this perfectly.\n    if (this.replacedStyleTop_) {\n      this.dialog_.style.top = '';\n      this.replacedStyleTop_ = false;\n    }\n\n    // Clear the backdrop and remove from the manager.\n    this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n    dialogPolyfill.dm.removeDialog(this);\n  },\n\n  /**\n   * @param {boolean} value whether to open or close this dialog\n   */\n  setOpen: function(value) {\n    if (value) {\n      this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');\n    } else {\n      this.dialog_.removeAttribute('open');\n      this.maybeHideModal();  // nb. redundant with MutationObserver\n    }\n  },\n\n  /**\n   * Handles clicks on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */\n  backdropClick_: function(e) {\n    if (!this.dialog_.hasAttribute('tabindex')) {\n      // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n      // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n      // would not be needed - clicks would move the implicit cursor there.\n      var fake = document.createElement('div');\n      this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n      fake.tabIndex = -1;\n      fake.focus();\n      this.dialog_.removeChild(fake);\n    } else {\n      this.dialog_.focus();\n    }\n\n    var redirectedEvent = document.createEvent('MouseEvents');\n    redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,\n        e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,\n        e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n    this.dialog_.dispatchEvent(redirectedEvent);\n    e.stopPropagation();\n  },\n\n  /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */\n  focus_: function() {\n    // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n    var target = this.dialog_.querySelector('[autofocus]:not([disabled])');\n    if (!target && this.dialog_.tabIndex >= 0) {\n      target = this.dialog_;\n    }\n    if (!target) {\n      // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n      // alternative involves stepping through and trying to focus everything.\n      var opts = ['button', 'input', 'keygen', 'select', 'textarea'];\n      var query = opts.map(function(el) {\n        return el + ':not([disabled])';\n      });\n      // TODO(samthor): tabindex values that are not numeric are not focusable.\n      query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');  // tabindex != \"\", not disabled\n      target = this.dialog_.querySelector(query.join(', '));\n    }\n    safeBlur(document.activeElement);\n    target && target.focus();\n  },\n\n  /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */\n  updateZIndex: function(dialogZ, backdropZ) {\n    if (dialogZ < backdropZ) {\n      throw new Error('dialogZ should never be < backdropZ');\n    }\n    this.dialog_.style.zIndex = dialogZ;\n    this.backdrop_.style.zIndex = backdropZ;\n  },\n\n  /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */\n  show: function() {\n    if (!this.dialog_.open) {\n      this.setOpen(true);\n      this.focus_();\n    }\n  },\n\n  /**\n   * Show this dialog modally.\n   */\n  showModal: function() {\n    if (this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');\n    }\n    if (!document.body.contains(this.dialog_)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');\n    }\n    if (!dialogPolyfill.dm.pushDialog(this)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');\n    }\n\n    if (createsStackingContext(this.dialog_.parentElement)) {\n      console.warn('A dialog is being shown inside a stacking context. ' +\n          'This may cause it to be unusable. For more information, see this link: ' +\n          'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');\n    }\n\n    this.setOpen(true);\n    this.openAsModal_ = true;\n\n    // Optionally center vertically, relative to the current viewport.\n    if (dialogPolyfill.needsCentering(this.dialog_)) {\n      dialogPolyfill.reposition(this.dialog_);\n      this.replacedStyleTop_ = true;\n    } else {\n      this.replacedStyleTop_ = false;\n    }\n\n    // Insert backdrop.\n    this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n\n    // Focus on whatever inside the dialog.\n    this.focus_();\n  },\n\n  /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */\n  close: function(opt_returnValue) {\n    if (!this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');\n    }\n    this.setOpen(false);\n\n    // Leave returnValue untouched in case it was set directly on the element\n    if (opt_returnValue !== undefined) {\n      this.dialog_.returnValue = opt_returnValue;\n    }\n\n    // Triggering \"close\" event for any attached listeners on the <dialog>.\n    var closeEvent = new supportCustomEvent('close', {\n      bubbles: false,\n      cancelable: false\n    });\n    this.dialog_.dispatchEvent(closeEvent);\n  }\n\n};\n\nvar dialogPolyfill = {};\n\ndialogPolyfill.reposition = function(element) {\n  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n  element.style.top = Math.max(scrollTop, topValue) + 'px';\n};\n\ndialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n  for (var i = 0; i < document.styleSheets.length; ++i) {\n    var styleSheet = document.styleSheets[i];\n    var cssRules = null;\n    // Some browsers throw on cssRules.\n    try {\n      cssRules = styleSheet.cssRules;\n    } catch (e) {}\n    if (!cssRules) { continue; }\n    for (var j = 0; j < cssRules.length; ++j) {\n      var rule = cssRules[j];\n      var selectedNodes = null;\n      // Ignore errors on invalid selector texts.\n      try {\n        selectedNodes = document.querySelectorAll(rule.selectorText);\n      } catch(e) {}\n      if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n        continue;\n      }\n      var cssTop = rule.style.getPropertyValue('top');\n      var cssBottom = rule.style.getPropertyValue('bottom');\n      if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\ndialogPolyfill.needsCentering = function(dialog) {\n  var computedStyle = window.getComputedStyle(dialog);\n  if (computedStyle.position !== 'absolute') {\n    return false;\n  }\n\n  // We must determine whether the top/bottom specified value is non-auto.  In\n  // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n  // Firefox returns the used value. So we do this crazy thing instead: check\n  // the inline style and then go through CSS rules.\n  if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||\n      (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {\n    return false;\n  }\n  return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n\n/**\n * @param {!Element} element to force upgrade\n */\ndialogPolyfill.forceRegisterDialog = function(element) {\n  if (window.HTMLDialogElement || element.showModal) {\n    console.warn('This browser already supports <dialog>, the polyfill ' +\n        'may not work correctly', element);\n  }\n  if (element.localName !== 'dialog') {\n    throw new Error('Failed to register dialog: The element is not a dialog.');\n  }\n  new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));\n};\n\n/**\n * @param {!Element} element to upgrade, if necessary\n */\ndialogPolyfill.registerDialog = function(element) {\n  if (!element.showModal) {\n    dialogPolyfill.forceRegisterDialog(element);\n  }\n};\n\n/**\n * @constructor\n */\ndialogPolyfill.DialogManager = function() {\n  /** @type {!Array<!dialogPolyfillInfo>} */\n  this.pendingDialogStack = [];\n\n  var checkDOM = this.checkDOM_.bind(this);\n\n  // The overlay is used to simulate how a modal dialog blocks the document.\n  // The blocking dialog is positioned on top of the overlay, and the rest of\n  // the dialogs on the pending dialog stack are positioned below it. In the\n  // actual implementation, the modal dialog stacking is controlled by the\n  // top layer, where z-index has no effect.\n  this.overlay = document.createElement('div');\n  this.overlay.className = '_dialog_overlay';\n  this.overlay.addEventListener('click', function(e) {\n    this.forwardTab_ = undefined;\n    e.stopPropagation();\n    checkDOM([]);  // sanity-check DOM\n  }.bind(this));\n\n  this.handleKey_ = this.handleKey_.bind(this);\n  this.handleFocus_ = this.handleFocus_.bind(this);\n\n  this.zIndexLow_ = 100000;\n  this.zIndexHigh_ = 100000 + 150;\n\n  this.forwardTab_ = undefined;\n\n  if ('MutationObserver' in window) {\n    this.mo_ = new MutationObserver(function(records) {\n      var removed = [];\n      records.forEach(function(rec) {\n        for (var i = 0, c; c = rec.removedNodes[i]; ++i) {\n          if (!(c instanceof Element)) {\n            continue;\n          } else if (c.localName === 'dialog') {\n            removed.push(c);\n          }\n          removed = removed.concat(c.querySelectorAll('dialog'));\n        }\n      });\n      removed.length && checkDOM(removed);\n    });\n  }\n};\n\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */\ndialogPolyfill.DialogManager.prototype.blockDocument = function() {\n  document.documentElement.addEventListener('focus', this.handleFocus_, true);\n  document.addEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});\n};\n\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */\ndialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n  document.documentElement.removeEventListener('focus', this.handleFocus_, true);\n  document.removeEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.disconnect();\n};\n\n/**\n * Updates the stacking of all known dialogs.\n */\ndialogPolyfill.DialogManager.prototype.updateStacking = function() {\n  var zIndex = this.zIndexHigh_;\n\n  for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n    dpi.updateZIndex(--zIndex, --zIndex);\n    if (i === 0) {\n      this.overlay.style.zIndex = --zIndex;\n    }\n  }\n\n  // Make the overlay a sibling of the dialog itself.\n  var last = this.pendingDialogStack[0];\n  if (last) {\n    var p = last.dialog.parentNode || document.body;\n    p.appendChild(this.overlay);\n  } else if (this.overlay.parentNode) {\n    this.overlay.parentNode.removeChild(this.overlay);\n  }\n};\n\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */\ndialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n  while (candidate = findNearestDialog(candidate)) {\n    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n      if (dpi.dialog === candidate) {\n        return i === 0;  // only valid if top-most\n      }\n    }\n    candidate = candidate.parentElement;\n  }\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n  if (this.containedByTopDialog_(event.target)) { return; }\n\n  if (document.activeElement === document.documentElement) { return; }\n\n  event.preventDefault();\n  event.stopPropagation();\n  safeBlur(/** @type {Element} */ (event.target));\n\n  if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key\n\n  var dpi = this.pendingDialogStack[0];\n  var dialog = dpi.dialog;\n  var position = dialog.compareDocumentPosition(event.target);\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    if (this.forwardTab_) {\n      // forward\n      dpi.focus_();\n    } else if (event.target !== document.documentElement) {\n      // backwards if we're not already focused on <html>\n      document.documentElement.focus();\n    }\n  }\n\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n  this.forwardTab_ = undefined;\n  if (event.keyCode === 27) {\n    event.preventDefault();\n    event.stopPropagation();\n    var cancelEvent = new supportCustomEvent('cancel', {\n      bubbles: false,\n      cancelable: true\n    });\n    var dpi = this.pendingDialogStack[0];\n    if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {\n      dpi.dialog.close();\n    }\n  } else if (event.keyCode === 9) {\n    this.forwardTab_ = !event.shiftKey;\n  }\n};\n\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */\ndialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n  // This operates on a clone because it may cause it to change. Each change also calls\n  // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n  // at a time?!\n  var clone = this.pendingDialogStack.slice();\n  clone.forEach(function(dpi) {\n    if (removed.indexOf(dpi.dialog) !== -1) {\n      dpi.downgradeModal();\n    } else {\n      dpi.maybeHideModal();\n    }\n  });\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */\ndialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n  var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n  if (this.pendingDialogStack.length >= allowed) {\n    return false;\n  }\n  if (this.pendingDialogStack.unshift(dpi) === 1) {\n    this.blockDocument();\n  }\n  this.updateStacking();\n  return true;\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n */\ndialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n  var index = this.pendingDialogStack.indexOf(dpi);\n  if (index === -1) { return; }\n\n  this.pendingDialogStack.splice(index, 1);\n  if (this.pendingDialogStack.length === 0) {\n    this.unblockDocument();\n  }\n  this.updateStacking();\n};\n\ndialogPolyfill.dm = new dialogPolyfill.DialogManager();\ndialogPolyfill.formSubmitter = null;\ndialogPolyfill.useValue = null;\n\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */\nif (window.HTMLDialogElement === undefined) {\n\n  /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */\n  var testForm = document.createElement('form');\n  testForm.setAttribute('method', 'dialog');\n  if (testForm.method !== 'dialog') {\n    var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');\n    if (methodDescriptor) {\n      // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n      // and don't bother to update the element.\n      var realGet = methodDescriptor.get;\n      methodDescriptor.get = function() {\n        if (isFormMethodDialog(this)) {\n          return 'dialog';\n        }\n        return realGet.call(this);\n      };\n      var realSet = methodDescriptor.set;\n      methodDescriptor.set = function(v) {\n        if (typeof v === 'string' && v.toLowerCase() === 'dialog') {\n          return this.setAttribute('method', v);\n        }\n        return realSet.call(this, v);\n      };\n      Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);\n    }\n  }\n\n  /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */\n  document.addEventListener('click', function(ev) {\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.useValue = null;\n    if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission\n\n    var target = /** @type {Element} */ (ev.target);\n    if (!target || !isFormMethodDialog(target.form)) { return; }\n\n    var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);\n    if (!valid) {\n      if (!(target.localName === 'input' && target.type === 'image')) { return; }\n      // this is a <input type=\"image\">, which can submit forms\n      dialogPolyfill.useValue = ev.offsetX + ',' + ev.offsetY;\n    }\n\n    var dialog = findNearestDialog(target);\n    if (!dialog) { return; }\n\n    dialogPolyfill.formSubmitter = target;\n\n  }, false);\n\n  /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */\n  var nativeFormSubmit = HTMLFormElement.prototype.submit;\n  var replacementFormSubmit = function () {\n    if (!isFormMethodDialog(this)) {\n      return nativeFormSubmit.call(this);\n    }\n    var dialog = findNearestDialog(this);\n    dialog && dialog.close();\n  };\n  HTMLFormElement.prototype.submit = replacementFormSubmit;\n\n  /**\n   * Global form 'dialog' method handler. Closes a dialog correctly on submit\n   * and possibly sets its return value.\n   */\n  document.addEventListener('submit', function(ev) {\n    var form = /** @type {HTMLFormElement} */ (ev.target);\n    if (!isFormMethodDialog(form)) { return; }\n    ev.preventDefault();\n\n    var dialog = findNearestDialog(form);\n    if (!dialog) { return; }\n\n    // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that\n    // the submitter is correct before using its value as .returnValue.\n    var s = dialogPolyfill.formSubmitter;\n    if (s && s.form === form) {\n      dialog.close(dialogPolyfill.useValue || s.value);\n    } else {\n      dialog.close();\n    }\n    dialogPolyfill.formSubmitter = null;\n\n  }, true);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (dialogPolyfill);\n\n\n//# sourceURL=webpack:///./node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/cartUpdates.js":
/*!*************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/cartUpdates.js ***!
  \*************************************************************/
/*! exports provided: default, getCartContent, cartApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return handleCartUpdates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCartContent\", function() { return getCartContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cartApi\", function() { return cartApi; });\n/* harmony import */ var _utils_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../utils/logging */ \"./utils/logging.js\");\n\nconst apiUrl = \"/cart.json\";\nfunction handleCartUpdates() {\n  window.addEventListener(\"load\", () => {\n    const cartForms = document.querySelectorAll('form[action=\"/cart\"]');\n\n    if (!cartForms.length) {\n      // No cart forms so we don't need a cart observer\n      return;\n    }\n\n    cartForms.forEach(cartForm => {\n      const cartFormWrapper = cartForm.parentNode; // Start observing the cart form for mutations\n\n      const mutationObserver = new MutationObserver(handleCartChange);\n      mutationObserver.observe(cartFormWrapper, {\n        childList: true\n      });\n    });\n  });\n  setupCartUpdate();\n  return;\n}\n\nconst isCartUrl = url => {\n  const urlChunks = url.split(\"/\");\n  let hasCartChunk = false;\n  urlChunks.forEach(chunk => {\n    if (chunk === \"cart\") {\n      hasCartChunk = true;\n    }\n  });\n  return hasCartChunk;\n};\n\nconst setupCartUpdate = () => {\n  window.OG.addOptinChangedCallback(async offer => {\n    const reloadCart = isCartUrl(window.location.pathname);\n    const offerElement = document.querySelector(`og-offer[product=\"${offer.productId}\"]`);\n    const lineNumber = offerElement && offerElement.getAttribute(\"data-line-id\");\n    const lineQuantity = offerElement && offerElement.getAttribute(\"data-line-qty\");\n\n    if (!lineNumber) {\n      return;\n    } // Let's get the current cart in order to prevent overriding line item properties\n\n\n    const currentLineProperties = await getCurrentLineProperties(lineNumber);\n    cartApi({\n      url: \"/cart/change.js\",\n      method: \"POST\",\n      body: {\n        id: lineNumber,\n        quantity: lineQuantity,\n        properties: { ...currentLineProperties,\n          og_subscription: `${offer.optedIn}`\n        }\n      },\n      reload: reloadCart\n    });\n  });\n};\n\nfunction handleCartChange(mutationsList, observer) {\n  const cartNodeName = \"FORM\";\n  const cartAction = \"/cart\";\n  const mutationsLength = mutationsList.length;\n  let x = 0;\n\n  for (x, mutationsLength; x < mutationsLength; x++) {\n    if (mutationsList[x].type === \"childList\") {\n      const addedNode = mutationsList[x].addedNodes[0];\n      const removedNode = mutationsList[x].removedNodes[0];\n\n      if (addedNode.nodeName == cartNodeName && addedNode.action.endsWith(cartAction) && removedNode.nodeName == cartNodeName && removedNode.action.endsWith(cartAction)) {\n        // cart updated, let's update og_settings\n        cartApi({\n          reload: false\n        });\n      }\n    }\n  }\n}\n\nconst updateOGSettings = ({\n  cartJson,\n  reload = true\n}) => {\n  if (cartJson.items) {\n    const products = cartJson.items.map(item => {\n      const unit_price = item.final_price / 100;\n      const total_price = item.final_line_price / 100;\n      return {\n        id: item.id,\n        quantity: item.quantity,\n        unit_price,\n        total_price\n      };\n    });\n    window.order_line_items = products.map(product => `${product.id}`);\n\n    if (reload) {\n      document.location.reload();\n    }\n  }\n}; // Helper function to retrieve the current line item properties for a particular line number\n\n\nconst getCurrentLineProperties = async lineNumber => {\n  const cartBody = await getCartContent();\n  if (!cartBody || !lineNumber) return {}; // make a quick exit. 🏃‍♂️💨\n\n  const lineItem = cartBody.items.length && cartBody.items.find(item => item.key == lineNumber);\n  return lineItem && lineItem.properties || {};\n}; // Helper function to return the cart contents\n\n\nconst getCartContent = async () => {\n  try {\n    const cartResponse = await fetch(apiUrl);\n\n    if (cartResponse.status !== 200) {\n      throw new Error(`Failed to get request, Shopify returned ${cartResponse.status} ${cartResponse.statusText}`);\n    }\n\n    return cartResponse.json();\n  } catch (err) {\n    /* uh oh, we have error. */\n    Object(_utils_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      domain: \"unknown\",\n      logPrefix: \"cartApi\",\n      error: err\n    });\n    return;\n  }\n};\nconst cartApi = ({\n  url,\n  method,\n  body,\n  reload = true\n}) => {\n  fetch(url || apiUrl, {\n    credentials: \"same-origin\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-Requested-With\": \"xmlhttprequest\"\n      /* XMLHttpRequest is ok too, it's case insensitive */\n\n    },\n    method: method || \"GET\",\n    body: body ? JSON.stringify(body) : null\n  }).then(response => {\n    return response.json();\n  }).then(cartJson => {\n    updateOGSettings({\n      cartJson,\n      reload\n    });\n  }).catch(err => {\n    /* uh oh, we have error. */\n    Object(_utils_logging__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      domain: \"unknown\",\n      logPrefix: \"cartApi\",\n      error: err\n    });\n    return;\n  });\n};\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/cartUpdates.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/cookies.js":
/*!*********************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/cookies.js ***!
  \*********************************************************/
/*! exports provided: getCookieValue, clearCookie, makeOGAuthRequest, setOGAuthCookieSafe, setOGAuthCookieUnSafe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCookieValue\", function() { return getCookieValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearCookie\", function() { return clearCookie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeOGAuthRequest\", function() { return makeOGAuthRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setOGAuthCookieSafe\", function() { return setOGAuthCookieSafe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setOGAuthCookieUnSafe\", function() { return setOGAuthCookieUnSafe; });\n/*\n  Helper function to get the value of a cookie by id\n*/\nconst getCookieValue = cookieId => {\n  const cookie = document.cookie.match(`(^|;) ?${cookieId}=([^;]*)(;|$)`);\n  return cookie ? cookie[2] : null;\n};\n/*\n  Helper function to clear a cookie by id.\n  Setting a past date on a cookie makes it invalid\n*/\n\nconst clearCookie = cookieId => {\n  // clear existing OG auth cookie\n  document.cookie = `${cookieId}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`;\n};\nconst makeOGAuthRequest = async customer => {\n  let auth = {};\n\n  try {\n    const response = await fetch(`/apps/subscriptions/auth/?customer=${customer.id}&customer_signature=${customer.signature}&customer_timestamp=${customer.timestamp}`, {\n      credentials: \"same-origin\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Requested-With\": \"xmlhttprequest\"\n        /* XMLHttpRequest is ok too, it's case insensitive */\n\n      },\n      method: \"GET\"\n    });\n    const data = await response.text();\n    const anchorPrefix = \"og_auth_\";\n    const beginAnchor = `${anchorPrefix}begin`;\n    const endAnchor = `${anchorPrefix}end`;\n    const beginningIndex = data.lastIndexOf(beginAnchor);\n\n    if (beginningIndex < 0) {\n      throw \"Invalid response from OG auth endpoint\";\n    }\n\n    auth = JSON.parse(data.substring(beginningIndex + beginAnchor.length, data.lastIndexOf(endAnchor)));\n  } catch (err) {\n    console.error(err);\n  }\n\n  return auth;\n};\nconst setOGAuthCookieSafe = async customer => {\n  const ogAuthCookie = getCookieValue(\"og_auth\"); // The cookie hasn't expired yet so we don't need to refresh the auth\n\n  if (ogAuthCookie) {\n    return;\n  }\n\n  const {\n    customerId,\n    timestamp,\n    signature\n  } = await makeOGAuthRequest(customer);\n\n  if (!customerId) {\n    return;\n  } // set expiration to now + 2hrs\n\n\n  const ogToday = new Date();\n  const binarySignature = btoa(signature);\n  ogToday.setTime(ogToday.getTime() + 2 * 60 * 60 * 1000);\n  document.cookie = `og_auth=${customerId}|${timestamp}|${binarySignature};expires=${ogToday.toUTCString()};secure;path=/`;\n};\nconst setOGAuthCookieUnSafe = customer => {\n  const signature = customer.signature;\n  const ogToday = new Date();\n  const binarySignature = btoa(signature); // set expiration to now + 2hrs\n\n  ogToday.setTime(ogToday.getTime() + 2 * 60 * 60 * 1000);\n  document.cookie = `og_auth=${customer.id}|${customer.timestamp}|${binarySignature};expires=${ogToday.toUTCString()};secure;path=/`;\n};\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/cookies.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/guestCheckout.js":
/*!***************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/guestCheckout.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dialog_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dialog-polyfill */ \"./node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage */ \"./server/lib/theme-partials/js/helpers/storage.js\");\n\n\n\nconst subscriptionCheckoutModal = (event, customer) => {\n  if (customer || !Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"getAutoshipValue\"])()) {\n    // Only show for guests with 1 or more subscriptions in cart\n    return true;\n  }\n\n  event.preventDefault(); // this is a subscription order. block guest checkout\n\n  const checkoutModal = document.getElementById(\"ordergrooveCheckoutModal\");\n\n  if (checkoutModal) {\n    const cartDrawer = document.getElementById(\"sidebar-cart\");\n    cartDrawer && cartDrawer.removeAttribute(\"tabIndex\");\n    dialog_polyfill__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerDialog(checkoutModal);\n    checkoutModal.showModal();\n    return false;\n  }\n};\n\nconst blockGuestCheckout = ({\n  customer\n}) => {\n  document.querySelector(\"body\").addEventListener(\"submit\", event => {\n    const formAction = event.target.getAttribute(\"action\");\n\n    if (formAction && formAction === \"/cart\") {\n      subscriptionCheckoutModal(event, customer);\n    }\n  });\n  document.querySelector(\"body\").addEventListener(\"click\", event => {\n    if (event.target.classList.contains(\"shopify-payment-button__button\")) {\n      subscriptionCheckoutModal(event, customer);\n    }\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (blockGuestCheckout);\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/guestCheckout.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/injectLineItemAttributes.js":
/*!**************************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/injectLineItemAttributes.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ \"./server/lib/theme-partials/js/helpers/storage.js\");\n/* harmony import */ var _ordergroove__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ordergroove */ \"./server/lib/theme-partials/js/helpers/ordergroove.js\");\n\n\nconst addToCartFormAction = \"/cart/add\";\n\nconst injectLineItemAttributes = () => {\n  window.addEventListener(\"load\", () => updateProductForms());\n  setInterval(() => {\n    updateProductForms();\n  }, 1500);\n};\n\nconst getProductOptin = ({\n  form\n}) => {\n  const ogOffer = form.querySelector('og-offer[os-version=\"1\"]');\n\n  if (!ogOffer) {\n    return null;\n  }\n\n  const subscribed = ogOffer.getAttribute(\"subscribed\");\n\n  if (subscribed !== null) {\n    return ogOffer.getAttribute(\"frequency\");\n  }\n\n  return null;\n};\n\nconst updateProductForms = () => {\n  togglePaymentButton();\n  const attributeName = \"data-og-check\"; // to skip forms in future for faster processing\n\n  const allProductForms = document.querySelectorAll(`form[action$=\"${addToCartFormAction}\"]:not([${attributeName}])`);\n  allProductForms.forEach(form => {\n    form.setAttribute(attributeName, true);\n    handleVariantChangeOnForm(form);\n    updateHiddenInputOnForm(form);\n  });\n};\n\nconst handleVariantChangeOnForm = form => {\n  const ogOffer = form.querySelector('og-offer[os-version=\"1\"]');\n\n  if (ogOffer) {\n    // Listen to variant changes in the form to update variant id in offer\n    form.addEventListener(\"change\", () => {\n      ogOffer.setAttribute(\"product\", form.id.value);\n    }); // Listen to variant id changes in offer to update og_subscription on form\n\n    const mutationObserver = new MutationObserver(function (mutations) {\n      mutations.forEach(function (mutation) {\n        if (mutation.type === \"attributes\" && (mutation.attributeName === \"subscribed\" || mutation.attributeName === \"frequency\")) {\n          updateHiddenInputOnForm(form);\n        }\n      });\n    });\n    mutationObserver.observe(ogOffer, {\n      attributes: true\n    });\n  }\n};\n\nconst updateHiddenInputOnForm = form => {\n  const hasSubscription = getProductOptin({\n    form\n  }) !== null;\n  const existingLineItemInput = form.querySelector(`input[name=\"properties[${_ordergroove__WEBPACK_IMPORTED_MODULE_1__[\"lineItemKey\"]}]\"]`);\n\n  if (existingLineItemInput) {\n    existingLineItemInput.value = hasSubscription;\n  } else {\n    injectHiddenInput({\n      form,\n      name: `properties[${_ordergroove__WEBPACK_IMPORTED_MODULE_1__[\"lineItemKey\"]}]`,\n      value: hasSubscription\n    });\n  }\n};\n\nconst injectHiddenInput = ({\n  form,\n  name,\n  value\n}) => {\n  const input = document.createElement(\"input\");\n  input.type = \"hidden\";\n  input.name = name;\n  input.value = `${value}`;\n  form.appendChild(input);\n};\n\nconst togglePaymentButton = () => {\n  const autoShipValue = Object(_storage__WEBPACK_IMPORTED_MODULE_0__[\"getAutoshipValue\"])();\n  const paymentButton = document.querySelector(\".shopify-payment-button\");\n\n  if (autoShipValue && paymentButton) {\n    paymentButton.style.display = \"none\";\n  } else if (!autoShipValue && paymentButton) {\n    paymentButton.style.display = \"block\";\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (injectLineItemAttributes);\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/injectLineItemAttributes.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/injectSellingPlanId.js":
/*!*********************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/injectSellingPlanId.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst addToCartFormAction = \"/cart/add\";\n\nconst injectSellingPlanId = () => {\n  window.addEventListener(\"load\", () => updateProductForms());\n  setInterval(() => {\n    updateProductForms();\n  }, 1500);\n};\n\nconst getOgOffer = ({\n  form\n}) => {\n  return form.querySelector('og-offer[os-version=\"1\"]');\n};\n\nconst getSellingPlanID = ({\n  ogOffer,\n  form\n}) => {\n  const subscribed = ogOffer.getAttribute(\"subscribed\");\n\n  if (subscribed === null) {\n    return null;\n  }\n\n  const variantId = ogOffer.getAttribute(\"product\");\n  const frequency = ogOffer.getAttribute(\"frequency\");\n  const sellingPlanMapElement = form.querySelector(`#og-selling-plan-map-${variantId}-${frequency}`);\n\n  if (sellingPlanMapElement) {\n    return sellingPlanMapElement.getAttribute(\"selling-plan-id\");\n  }\n\n  return null;\n};\n\nconst updateProductForms = () => {\n  const attributeName = \"data-og-check\"; // to skip forms in future for faster processing\n\n  const allProductForms = document.querySelectorAll(`form[action$=\"${addToCartFormAction}\"]:not([${attributeName}])`);\n\n  if (allProductForms.length === 0) {\n    const ogOffer = getOgOffer({\n      form: document\n    });\n    if (!ogOffer) return;\n    const planID = getSellingPlanID({\n      ogOffer,\n      form: document\n    });\n    window.og_selling_plan_id = planID;\n    return;\n  }\n\n  allProductForms.forEach(form => {\n    form.setAttribute(attributeName, true);\n    handleVariantChangeOnForm(form);\n    updateHiddenInputOnForm(form);\n  });\n};\n\nconst handleVariantChangeOnForm = form => {\n  const ogOffer = form.querySelector('og-offer[os-version=\"1\"]');\n\n  if (ogOffer) {\n    // Listen to variant changes in the form to update variant id in offer\n    form.addEventListener(\"change\", () => {\n      ogOffer.setAttribute(\"product\", form.id.value);\n    }); // Listen to variant id changes in offer to update selling plan in form\n\n    const mutationObserver = new MutationObserver(function (mutations) {\n      mutations.forEach(function (mutation) {\n        if (mutation.type === \"attributes\" && (mutation.attributeName === \"subscribed\" || mutation.attributeName === \"frequency\")) {\n          updateHiddenInputOnForm(form);\n        }\n      });\n    });\n    mutationObserver.observe(ogOffer, {\n      attributes: true\n    });\n  }\n};\n\nconst updateHiddenInputOnForm = form => {\n  const ogOffer = getOgOffer({\n    form\n  });\n  if (!ogOffer) return;\n  const planID = getSellingPlanID({\n    ogOffer,\n    form\n  });\n  window.og_selling_plan_id = planID;\n  const existingSellingPlanInput = form.querySelector('input[name=\"selling_plan\"]');\n\n  if (!planID) {\n    if (existingSellingPlanInput) {\n      // Remove existing hidden selling plan input\n      existingSellingPlanInput.remove();\n    }\n  } else {\n    if (existingSellingPlanInput) {\n      // Set existing hidden selling plan input to new plan id\n      existingSellingPlanInput.value = planID;\n    } else {\n      injectHiddenInput({\n        form,\n        name: \"selling_plan\",\n        value: planID\n      });\n    }\n  }\n};\n\nconst injectHiddenInput = ({\n  form,\n  name,\n  value\n}) => {\n  const input = document.createElement(\"input\");\n  input.type = \"hidden\";\n  input.name = name;\n  input.value = `${value}`;\n  form.appendChild(input);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (injectSellingPlanId);\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/injectSellingPlanId.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/ordergroove.js":
/*!*************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/ordergroove.js ***!
  \*************************************************************/
/*! exports provided: lineItemKey, localStorageKey, injectInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineItemKey\", function() { return lineItemKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localStorageKey\", function() { return localStorageKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"injectInput\", function() { return injectInput; });\nconst lineItemKey = \"og_subscription\";\nconst localStorageKey = \"OG_STATE\";\n/*\n  Helper function to inject a hidden input append to an element\n\n  Mainly used to inject cookies as input. Defaults as hidden input type\n*/\n\nconst injectInput = ({\n  name,\n  value,\n  element,\n  inputType\n}) => {\n  const input = document.createElement(\"input\");\n  input.type = inputType ? inputType : \"hidden\";\n  input.name = name;\n  input.value = value;\n  element.appendChild(input);\n};\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/ordergroove.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/pdpUpdates.js":
/*!************************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/pdpUpdates.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return handlePDPUpdates; });\n/* harmony import */ var _cartUpdates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartUpdates */ \"./server/lib/theme-partials/js/helpers/cartUpdates.js\");\n\nfunction handlePDPUpdates() {\n  window.OG.addOptinChangedCallback(async offer => {\n    // Let's get the current cart in order to prevent overriding line item properties\n    const {\n      key,\n      quantity,\n      properties\n    } = await getCurrentLine(offer.productId);\n\n    if (!key) {\n      return;\n    }\n\n    Object(_cartUpdates__WEBPACK_IMPORTED_MODULE_0__[\"cartApi\"])({\n      url: \"/cart/change.js\",\n      method: \"POST\",\n      body: {\n        id: key,\n        quantity: quantity,\n        properties: { ...properties,\n          og_subscription: `${offer.optedIn}`\n        }\n      },\n      reload: false\n    });\n  });\n} // Helper function to retrieve the current line item for a particular variant id\n\nconst getCurrentLine = async productId => {\n  const cartBody = await Object(_cartUpdates__WEBPACK_IMPORTED_MODULE_0__[\"getCartContent\"])();\n  if (!cartBody || !productId) return {}; // make a quick exit. 🏃‍♂️💨\n\n  const lineItem = cartBody.items.length && cartBody.items.find(item => item.variant_id == productId);\n  return lineItem && {\n    key: lineItem.key,\n    properties: lineItem.properties,\n    quantity: lineItem.quantity\n  } || {};\n};\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/pdpUpdates.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/helpers/storage.js":
/*!*********************************************************!*\
  !*** ./server/lib/theme-partials/js/helpers/storage.js ***!
  \*********************************************************/
/*! exports provided: getAutoshipValue, getOptins, getOptinsForProducts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAutoshipValue\", function() { return getAutoshipValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptins\", function() { return getOptins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptinsForProducts\", function() { return getOptinsForProducts; });\n/* harmony import */ var _ordergroove__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ordergroove */ \"./server/lib/theme-partials/js/helpers/ordergroove.js\");\n\n\nconst getOGState = () => {\n  const data = _ordergroove__WEBPACK_IMPORTED_MODULE_0__[\"localStorageKey\"] && JSON.parse(localStorage.getItem(_ordergroove__WEBPACK_IMPORTED_MODULE_0__[\"localStorageKey\"]));\n  return data;\n};\n\nconst getAutoshipValue = () => {\n  const optins = getOptinsForProducts(window.order_line_items);\n  return optins.length > 0;\n};\nconst getOptins = () => {\n  if (typeof OG === \"undefined\" || typeof OG.getOptins !== \"function\") {\n    console.warn(\"OG or OG.getOptins does not exist!\");\n    return [];\n  }\n\n  return OG.getOptins();\n};\nconst getOptinsForProducts = optins => {\n  if (typeof OG === \"undefined\" || typeof OG.getOptins !== \"function\") {\n    console.warn(\"OG or OG.getOptins does not exist!\");\n    return [];\n  }\n\n  return OG.getOptins(optins);\n};\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/helpers/storage.js?");

/***/ }),

/***/ "./server/lib/theme-partials/js/index.js":
/*!***********************************************!*\
  !*** ./server/lib/theme-partials/js/index.js ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_guestCheckout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/guestCheckout */ \"./server/lib/theme-partials/js/helpers/guestCheckout.js\");\n/* harmony import */ var _helpers_injectLineItemAttributes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/injectLineItemAttributes */ \"./server/lib/theme-partials/js/helpers/injectLineItemAttributes.js\");\n/* harmony import */ var _helpers_injectSellingPlanId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/injectSellingPlanId */ \"./server/lib/theme-partials/js/helpers/injectSellingPlanId.js\");\n/* harmony import */ var _helpers_cartUpdates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/cartUpdates */ \"./server/lib/theme-partials/js/helpers/cartUpdates.js\");\n/* harmony import */ var _helpers_pdpUpdates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/pdpUpdates */ \"./server/lib/theme-partials/js/helpers/pdpUpdates.js\");\n/* harmony import */ var _helpers_cookies__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/cookies */ \"./server/lib/theme-partials/js/helpers/cookies.js\");\n/* harmony import */ var _utils_gateway_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../utils/gateway-constants */ \"./utils/gateway-constants.js\");\n\n\n\n\n\n\n\nconst OrdergrooveShopify = {\n  init({\n    customer,\n    settings\n  }) {\n    const guestCheckoutBlocked = settings && settings.blockGuestCheckout;\n    const isShopifyPaymentsMerchant = settings && settings.gateway === _utils_gateway_constants__WEBPACK_IMPORTED_MODULE_6__[\"default\"].SHOPIFY_PAYMENTS;\n    const shouldUseSafeAssets = settings && settings.shouldUseSafeAssets;\n\n    if (customer) {\n      if (shouldUseSafeAssets) {\n        Object(_helpers_cookies__WEBPACK_IMPORTED_MODULE_5__[\"setOGAuthCookieSafe\"])(customer);\n      } else {\n        Object(_helpers_cookies__WEBPACK_IMPORTED_MODULE_5__[\"setOGAuthCookieUnSafe\"])(customer);\n      }\n    } else {\n      Object(_helpers_cookies__WEBPACK_IMPORTED_MODULE_5__[\"clearCookie\"])(\"og_auth\");\n    }\n\n    if (isShopifyPaymentsMerchant) {\n      Object(_helpers_injectSellingPlanId__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n    } else {\n      Object(_helpers_injectLineItemAttributes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n      Object(_helpers_cartUpdates__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n      Object(_helpers_pdpUpdates__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    }\n\n    if (guestCheckoutBlocked) {\n      Object(_helpers_guestCheckout__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        customer\n      });\n    }\n  }\n\n};\nwindow.ogShopify = OrdergrooveShopify.init(window.ogShopifyConfigOSv1);\n\n//# sourceURL=webpack:///./server/lib/theme-partials/js/index.js?");

/***/ }),

/***/ "./utils/gateway-constants.js":
/*!************************************!*\
  !*** ./utils/gateway-constants.js ***!
  \************************************/
/*! exports provided: gatewayNames, gatewayNamesToShopifyNames, authNetConsts, cardTypes, captureOptions, VAULT_MODE, GATE_MODE, OG_MODE, OG_ORDER_VERIFICATION_URL, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gatewayNames\", function() { return gatewayNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gatewayNamesToShopifyNames\", function() { return gatewayNamesToShopifyNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authNetConsts\", function() { return authNetConsts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cardTypes\", function() { return cardTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"captureOptions\", function() { return captureOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VAULT_MODE\", function() { return VAULT_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GATE_MODE\", function() { return GATE_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OG_MODE\", function() { return OG_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OG_ORDER_VERIFICATION_URL\", function() { return OG_ORDER_VERIFICATION_URL; });\nconst gatewayNames = {\n  CYBER_SOURCE: \"cyberSource\",\n  AUTH_NET: \"authNet\",\n  SHOPIFY_PAYMENTS: \"shopifyPayments\"\n};\nconst gatewayNamesToShopifyNames = {\n  cyberSource: \"CyberSource\",\n  authNet: \"Authorize.net\",\n  shopifyPayments: \"Shopify Payments\"\n}; // Error code lookup:\n// https://developer.authorize.net/api/reference/responseCodes.html\n\nconst authNetConsts = {\n  customerProfileCreateError: \"E00039\",\n  creditFailure: \"54\",\n  profileDoesNotExistError: \"E00040\"\n};\nconst cardTypes = value => {\n  switch (value) {\n    case \"4\":\n    case \"001\":\n    case \"Visa\":\n      return \"1\";\n\n    case \"5\":\n    case \"002\":\n    case \"MasterCard\":\n      return \"2\";\n\n    case \"3\":\n    case \"003\":\n    case \"AmericanExpress\":\n      return \"3\";\n\n    case \"6\":\n    case \"042\":\n    case \"Discover\":\n      return \"4\";\n  }\n};\nconst captureOptions = [{\n  label: \"At authorization\",\n  value: \"at_auth\",\n  helpText: \"The customer's payment will be automatically captured at order placement.\"\n}, {\n  label: \"At fulfillment\",\n  value: \"at_fulfillment\",\n  helpText: \"The customer's payment will be captured at first shipment.\"\n}];\nconst VAULT_MODE = function (isStaging, gateway) {\n  let url = \"\";\n\n  switch (gateway) {\n    case gatewayNames.CYBER_SOURCE:\n      isStaging ? url = \"https://testflex.cybersource.com/cybersource/assets/microform/0.4.4/flex-microform.min.js\" : url = \"https://flex.cybersource.com/cybersource/assets/microform/0.4.4/flex-microform.min.js\";\n      break;\n\n    case gatewayNames.AUTH_NET:\n      isStaging ? url = \"https://jstest.authorize.net/v3/AcceptUI.js\" : url = \"https://js.authorize.net/v3/AcceptUI.js\";\n\n    default:\n      break;\n  }\n\n  return url;\n};\nconst GATE_MODE = function (isStaging, gateway) {\n  let url = \"\";\n\n  switch (gateway) {\n    case gatewayNames.CYBER_SOURCE:\n      isStaging ? url = \"https://ics2wstesta.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.158.wsdl\" : url = \"https://ics2wsa.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.158.wsdl\";\n      break;\n\n    default:\n      break;\n  }\n\n  return url;\n};\nconst OG_MODE = function (type = \"UPDATE\") {\n  let url = \"\";\n\n  if (type === \"CREATE\") {\n    url = `${process.env.BASE_URL_SC}/subscription/create`;\n  } else {\n    url = `${process.env.BASE_URL_API}/customer/update_payment_default`;\n  }\n\n  return url;\n}; // Ordergroove order verification API endpoint\n\nconst OG_ORDER_VERIFICATION_URL = () => `${process.env.BASE_URL_API}/order/verify`;\n/* harmony default export */ __webpack_exports__[\"default\"] = (gatewayNames);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./utils/gateway-constants.js?");

/***/ }),

/***/ "./utils/logging.js":
/*!**************************!*\
  !*** ./utils/logging.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst printError = payload => {\n  const {\n    domain,\n    logPrefix = \"\",\n    error\n  } = payload;\n  let useError = error;\n  let stackNum = 0;\n\n  if (typeof error === \"string\") {\n    useError = new Error(error);\n    stackNum = 1;\n  }\n\n  let errorObject = {\n    domain,\n    error: useError.message\n  };\n  const stack = stackTrace.parse(useError);\n  errorObject.fileName = stack[stackNum] && stack[stackNum].fileName;\n  errorObject.line = stack[stackNum] && stack[stackNum].lineNumber;\n  console.error(`${logPrefix} ${JSON.stringify(errorObject)}`);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (printError);\n\n//# sourceURL=webpack:///./utils/logging.js?");

/***/ })

/******/ });